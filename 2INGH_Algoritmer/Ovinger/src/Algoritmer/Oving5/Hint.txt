• Hashtabeller er normalt raske. Det kan bli problemer med tidtaking, bruk i
så fall trikset fra første øving, hvor operasjonen kjøres flere ganger på rad.
• Hvis det tar flere minutter å sette tallene inn i hashtabellen, har dere problemer
med hashfunksjonene deres. Vanlige feil her:
? h2 blir 0 for noen nøkler. Det fører i så fall til en uendelig løkke så
programmet aldri blir ferdig. Pass på at h2 aldri kan bli 0, og heller aldri
lik tabellstørrelsen.
? h1 klarer ikke å spre nøklene utover hele tabellen. I så fall får dere altfor
mange kollisjoner, og tidsforbruket blir kvadratisk.
? De tilfeldige tallene ligger i et smalere intervall enn tabellstørrelsen, så
det blir veldig mange duplikater blant ti millioner tall. Tall med samme
verdi kolliderer alltid – og dobbel hashing hjelper heller ikke i slike
tilfeller!
? Dere har brukt et interpretert språk, i stedet for et kompilert programmeringsspråk.
Prøv i så fall med en mindre tabell.
• Se opp for «arithmetic overflow», altså operasjoner som lager altfor store
heltall. Ta f.eks. en uheldig beregning som «pos=(h1+i*h2)%m». Her kan i
blir svært stor, når tabellen nærmer seg full. Da blir i*h2 større enn området
for int, og slik overflow kan føre til negative tall. Deretter følger en «index
out of bounds exception» når programmet slår opp en negativ tabellindex.
Løsningen er enkel. Bruk heller en løkke med «pos=(pos+h2)%m» Det er bra
fordi:
1. Negative tall oppstår ikke. Vi har ikke multiplikasjon, bare addisjon som
er mindre voldsomt.
2. Programmet blir litt raskere fordi vi har en multiplikasjon mindre i løkka.
Hashtabeller handler om raskest mulig kode.